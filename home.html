<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
	</head>

	<body>
		<div id="container"></div>

		<script type="x-shader/x-vertex" id="vertexshader">

			attribute float size;
			attribute vec3 customColor;

			varying vec3 vColor;

			void main() {

				vColor = customColor;

				vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );

				gl_PointSize = size * ( 600.0 / -mvPosition.z );

				gl_Position = projectionMatrix * mvPosition;

			}

		</script>

		<script type="x-shader/x-fragment" id="fragmentshader">

			uniform vec3 color;
			uniform sampler2D pointTexture;

			varying vec3 vColor;

			void main() {

				gl_FragColor = vec4( color * vColor, 1.0 );
				gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );

			}

		</script>
		<script src="https://code.jquery.com/jquery-1.10.2.js"></script>
		<script type="text/javascript">
			$('#menu-toggle').click(function(){
			  $(this).toggleClass('open');
			})
		</script>

		<script type="module">

			import * as THREE from '../build/three.module.js';

			import Stats from './jsm/libs/stats.module.js';

			var renderer, scene, camera, stats;
			var amount = 2000;
			var amountStar = 1200;
			var theta = Math.PI * 2 / amount;
			var radius = 250;
			var r = 30;
			var circleCenter = new THREE.Vector3(0, 0, 0);
			var indent = 5;
			var ecart = indent / 2;

			var sphere, stars;

			var WIDTH = window.innerWidth;
			var HEIGHT = window.innerHeight;

			var mouseX = 0, mouseY = 0;

			var windowHalfX = window.innerWidth / 2;
			var windowHalfY = window.innerHeight / 2;

			var positions = new Float32Array( amount * 3 );
			var positionsStar = new Float32Array( amountStar * 3 );

			var pulseStars = 0;

			var fallbackPulse = 0;

			var sound;

			init();
			animate();

			function init() {

				camera = new THREE.PerspectiveCamera( 40, WIDTH / HEIGHT, 1, 10000 );
				camera.position.z = 300;

				scene = new THREE.Scene();

				var colors = new Float32Array( amount * 3 );
				var sizes = new Float32Array( amount );

				var vertex = new THREE.Vector3();
				var color = new THREE.Color( 0xffffff );

				var vertexStar = new THREE.Vector3();
				var colorsStar = new Float32Array( amount * 3 );
				var sizesStar = new Float32Array( amount );

				for ( var i = 0; i < amount; i ++ ) {

					
					vertex.x = 1500 * Math.random() - 750;
					vertex.y = 1500 * Math.random() - 750;
					vertex.z = 1500 * Math.random() - 750;
					
					vertex.toArray( positions, i * 3 );

					color.setHSL( ( 360 * ( 1.0 + 0.5 ) % 360 ) / 360 , 0.5, 0.5  );

					color.toArray( colors, i * 3 );

					sizes[ i ] = 5;
				}
				for ( var i = 0; i < amountStar; i ++ ) {
					
					vertexStar.x = 4000 * Math.random() - 2000;
					vertexStar.y = 4000 * Math.random() - 2000;
					vertexStar.z = 4000 * Math.random() - 2000;
					
					vertexStar.toArray( positionsStar, i * 3 );

					color.setHSL( ( 360 * ( 1.0 + Math.random() ) % 360 ) / 360 , 0.3, 0.7  );

					color.toArray( colorsStar, i * 3 );

					sizesStar[ i ] = 0;
				}

				var geometry = new THREE.BufferGeometry();
				geometry.addAttribute( 'position', new THREE.BufferAttribute( positions, 3 ) );
				geometry.addAttribute( 'customColor', new THREE.BufferAttribute( colors, 3 ) );
				geometry.addAttribute( 'size', new THREE.BufferAttribute( sizes, 1 ) );

				var geometryStar = new THREE.BufferGeometry();
				geometryStar.addAttribute( 'position', new THREE.BufferAttribute( positionsStar, 3 ) );
				geometryStar.addAttribute( 'customColor', new THREE.BufferAttribute( colorsStar, 3 ) );
				geometryStar.addAttribute( 'size', new THREE.BufferAttribute( sizesStar, 1 ) );

				//

				var material = new THREE.ShaderMaterial( {

					uniforms: {
						color: { value: new THREE.Color( 0xffffff ) },
						pointTexture: { value: new THREE.TextureLoader().load( "textures/sprites/disc.png" ) }
					},
					vertexShader: document.getElementById( 'vertexshader' ).textContent,
					fragmentShader: document.getElementById( 'fragmentshader' ).textContent,

					blending: THREE.AdditiveBlending,
					depthTest: false,
					transparent: true

				} );

				//

				sphere = new THREE.Points( geometry, material );
				scene.add( sphere );

				stars = new THREE.Points( geometryStar, material );
				scene.add( stars );

				//

				renderer = new THREE.WebGLRenderer();
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( WIDTH, HEIGHT );

				var container = document.getElementById( 'container' );
				container.appendChild( renderer.domElement );
				var fallback = 0;
				
				container.addEventListener("click", function(){
					/*
					if(fallback == 0){
						animateOnce();
						fallback = 1;
						setTimeout(function(){
							fallback = 0;
						}, 3500)
					}*/
					createListener("BMTH");
				})
				circle(2000);

				//
				document.addEventListener( 'mousemove', onDocumentMouseMove, false );
				document.addEventListener( 'touchstart', onDocumentTouchStart, false );
				document.addEventListener( 'touchmove', onDocumentTouchMove, false );

				window.addEventListener( 'resize', onWindowResize, false );


			}


			function createListener(name){
				for (var i = 0; i < camera.children.length; i++) {
				    if(camera.children[i].type == "AudioListener"){
				    	camera.children[i].children[0].pause()
				    	camera.remove(camera.children[i])
				    }
				}

				var listener = new THREE.AudioListener();
				listener.context.resume()

				if(listener.context.state == "suspended"){
					listener.context.resume()
				}

				camera.add( listener );

				//initStars();

				// create an Audio source
				sound = new THREE.Audio( listener );
				sound.name = name
				sound.pause()
				listener.add(sound)
				// load a sound and set it as the Audio object's buffer
				var audioLoader = new THREE.AudioLoader();
				audioLoader.load( 'sounds/' + name + '.mp3', function( buffer ) {
					sound.setBuffer( buffer );
					sound.setLoop(false);
					sound.setVolume(0.5);
					sound.play();
				});

				// create an AudioAnalyser, passing in the sound and desired fftSize
				var analyser = new THREE.AudioAnalyser( sound, 32 );

				r = 1;
				circle(500);
				setTimeout(function(){
					r += 39;
					var geometry = sphere.geometry;
					var attributes = geometry.attributes;
					var position = attributes.position;
					var vector = new THREE.Vector3();
					

					var positionSound = new Float32Array( amount * 3 );
					// get the average frequency of the sound
					setInterval(function(){
						var data = (analyser.getAverageFrequency());
						var color = (analyser.getAverageFrequency());
						//var color = (analyser.getFrequencyData()[9]);
						r = color/2;
						for ( var i = 0; i < amount; i++ ) 
						{
							var lambda = Math.acos(2 * Math.random() -1) - Math.PI / 2;
							var phi = 2 * Math.PI * Math.random();

							vector.x = circleCenter.x + (r + (Math.random() - 0.5) * 2) * Math.cos(lambda) * Math.cos(phi)
							vector.y = circleCenter.y + (r + (Math.random() - 0.5) * 2) * Math.cos(lambda) * Math.sin(phi)
							vector.z = circleCenter.z + (r + (Math.random() - 0.5) * 2) * Math.sin(lambda)

							vector.toArray(positionSound, i * 3);

						
						}
						var onchange = 0;
						attributes.position.needsUpdate = true;
						animateWhilePlay(positionSound);
						animateStars(color);
						
					}, 10)
				}, 500)

			}

			function animateStars(data){
				if(data > 40){
					var geometry = stars.geometry;
					var attributes = geometry.attributes;
					attributes.size.array[Math.round(Math.random()*amountStar)] = 10;
					attributes.size.needsUpdate = true;
				}
				if (data > 80){
					if(fallbackPulse == 0){
						pulseStars = 1;
						fallbackPulse = 1;
						setTimeout(function(){
							pulseStars = 2;
							setTimeout(function(){
								pulseStars = 0;
								fallbackPulse = 0;
							}, 100)
						}, 100)
					}
				}

			}

			function animateOnce(){
				indent = 8;
				ecart = indent/2;
				r = 30;
				circle(1000);
				setTimeout(function(){
					r = 1;
					circle(500);
					setTimeout(function(){
						explosion();
					}, 500)
				}, 1000)
			}

			function animateWhilePlay(finalPositions){
				var geometry = sphere.geometry;
				var attributes = geometry.attributes;
				for ( var i = 0; i < amount*3; i += 3 ) 
				{
					attributes.position.array[i] = finalPositions[i];
					attributes.position.array[i+1] = finalPositions[i+1]
					attributes.position.array[i+2] = finalPositions[i+2];
				}
				attributes.position.needsUpdate = true;
				attributes.customColor.needsUpdate = true;
			}

			function onWindowResize() {

				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();

				renderer.setSize( window.innerWidth, window.innerHeight );

			}

			function onDocumentMouseMove( event ) {

				mouseX = event.clientX - windowHalfX;
				mouseY = event.clientY - windowHalfY;

			}

			function onDocumentTouchStart( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function onDocumentTouchMove( event ) {

				if ( event.touches.length == 1 ) {

					event.preventDefault();

					mouseX = event.touches[ 0 ].pageX - windowHalfX;
					mouseY = event.touches[ 0 ].pageY - windowHalfY;

				}

			}

			function animate() {

				requestAnimationFrame( animate );

				render();

			}

			function render() {

				var time = Date.now() * 0.00005;
				var angle = (( 360 * ( 1.0 + time ) % 360 ) / 360)  * Math.PI * 2;
				
				camera.position.x = 0 + 300 * Math.cos(angle)
				camera.position.z = 0 + 300 * Math.sin(angle)

			


				camera.lookAt( scene.position );
				
				var geometry = sphere.geometry;
				var attributes = geometry.attributes;

				var couleur1 = ( 360 * ( 1.0 + time ) % 360 ) / 360;
				var couleur2 = 0.3;
				var couleur3 = 0.7;

				for ( var i = 0; i < attributes.size.array.length; i ++ ) {

					attributes.size.array[ i ] = 1 + 8 * Math.sin( 0.1 * i + time );
					attributes.customColor.array[i*3] = couleur1;
					attributes.customColor.array[i*3+1] = couleur2;
					attributes.customColor.array[i*3+2] =couleur3;
				}
				attributes.size.needsUpdate = true;
				attributes.customColor.needsUpdate = true;

				if(pulseStars == 1){
					var geometry = stars.geometry;
					var attributes = geometry.attributes;

					for ( var i = 0; i < attributes.size.array.length; i ++ ) {
						if(attributes.size.array[i] >= 10)
							attributes.size.array[i] += 0.5;

						attributes.size.needsUpdate = true;
					}
				}
				if(pulseStars == 2){
					var geometry = stars.geometry;
					var attributes = geometry.attributes;

					for ( var i = 0; i < attributes.size.array.length; i ++ ) {
						if(attributes.size.array[i] > 10)
							attributes.size.array[i] -= 0.5;
						attributes.size.needsUpdate = true;
					}
				}
				if(pulseStars == 3){
					var geometry = stars.geometry;
					var attributes = geometry.attributes;

					for ( var i = 0; i < attributes.size.array.length; i ++ ) {
						if(attributes.size.array[i] >= 0.5)
							attributes.size.array[i] -= 0.5;
						attributes.size.needsUpdate = true;
					}
					pulseStars = 0;
				}

				if(sound){
					if(!sound.isPlaying){
						var geometry = stars.geometry;
						var attributes = geometry.attributes;
						/*
						for ( var i = 0; i < attributes.size.array.length; i ++ ) {
							attributes.size.array[i] = 0;
							attributes.size.needsUpdate = true;
						}*/
						pulseStars = 3;
					}
				}

				renderer.render( scene, camera );


			}
			function circle(delay){
				var geometry = sphere.geometry;
				var attributes = geometry.attributes;
				var position = attributes.position;
				var vector = new THREE.Vector3();

				var finalPositions = new Float32Array( amount * 3 );

				for ( var i = 0; i < amount; i++ ) 
				{
					var lambda = Math.acos(2 * Math.random() -1) - Math.PI / 2;
					var phi = 2 * Math.PI * Math.random();

					vector.x = circleCenter.x + r * Math.cos(lambda) * Math.cos(phi)
					vector.y = circleCenter.y + r * Math.cos(lambda) * Math.sin(phi)
					vector.z = circleCenter.z + r * Math.sin(lambda)

					vector.toArray(finalPositions, i * 3);
				
				}
				attributes.position.needsUpdate = true;
				if(delay <= 500)
					indent  = 1
				ecart = indent / 2
				var interSphere = setInterval(function(){
					for ( var i = 0; i < amount*3; i += 3 ) 
					{
						if(attributes.position.array[i] > finalPositions[i] + ecart )
							attributes.position.array[i] -= indent;
						else if (attributes.position.array[i] < finalPositions[i] - ecart)
							attributes.position.array[i] += indent;
						else
							attributes.position.array[i] = finalPositions[i]

						if(attributes.position.array[i+1] > finalPositions[i+1] + ecart)
							attributes.position.array[i+1] -= indent;
						else if (attributes.position.array[i+1] < finalPositions[i+1] - ecart)
							attributes.position.array[i+1] += indent;
						else
							attributes.position.array[i+1] = finalPositions[i+1]
						
						if(attributes.position.array[i+2] > finalPositions[i+2] + ecart)
							attributes.position.array[i+2] -= indent;
						else if(attributes.position.array[i+2] < finalPositions[i+2] - ecart)
							attributes.position.array[i+2] += indent;
						else
							attributes.position.array[i+2] = finalPositions[i+2];
					}
					attributes.position.needsUpdate = true;
				}, 10)
				setTimeout(function(){
					clearInterval(interSphere);
				}, delay)
			}
			function explosion(){
				
				var geometry = sphere.geometry;
				var attributes = geometry.attributes;
				var vector = new THREE.Vector3();
				var positions = new Float32Array( amount * 3 );
				for ( var i = 0; i < amount; i ++ ) {
					
					r = Math.random() * 4000 + 30;

					var lambda = Math.acos(2 * Math.random() -1) - Math.PI / 2;
					var phi = 2 * Math.PI * Math.random();

					vector.x = circleCenter.x + r * Math.cos(lambda) * Math.cos(phi)
					vector.y = circleCenter.y + r * Math.cos(lambda) * Math.sin(phi)
					vector.z = circleCenter.z + r * Math.sin(lambda)

					vector.toArray(positions, i * 3);

				}
				var geometry = sphere.geometry;
				var attributes = geometry.attributes;
				
				var interExplosion = setInterval(function(){
					for ( var i = 0; i < amount*3; i += 3 ) 
					{

						indent = Math.random() * 10;
						ecart = indent/2;
						if(attributes.position.array[i] > positions[i] + ecart )
							attributes.position.array[i] -= indent;
						else if (attributes.position.array[i] < positions[i] - ecart)
							attributes.position.array[i] += indent;
						else
							attributes.position.array[i] = positions[i]

						if(attributes.position.array[i+1] > positions[i+1] + ecart)
							attributes.position.array[i+1] -= indent;
						else if (attributes.position.array[i+1] < positions[i+1] - ecart)
							attributes.position.array[i+1] += indent;
						else
							attributes.position.array[i+1] = positions[i+1]
						
						if(attributes.position.array[i+2] > positions[i+2] + ecart)
							attributes.position.array[i+2] -= indent;
						else if(attributes.position.array[i+2] < positions[i+2] - ecart)
							attributes.position.array[i+2] += indent;
						else
							attributes.position.array[i+2] = positions[i+2];

					}
					attributes.position.needsUpdate = true;
				}, 10)

				setTimeout(function(){
					clearInterval(interExplosion);
				}, 1000)
			}

		</script>

</body>

</html>
